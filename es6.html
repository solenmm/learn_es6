<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ES6</title>
</head>
<body>
  <p>
    ES5 只有全局作用域和函数作用域，没有块级作用域，let实际上为 JavaScript 新增了块级作用域。
    ES6允许块级作用域中声明函数，且最好使用函数表达式，而不是函数声明语句。
    块级作用域必须是花括号包裹，否则会报错

    const一旦声明变量，就必须立即初始化，不能留到以后赋值，否则会报错。

    对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
    例如
    let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
    baz // "aaa"
    foo // error: foo is not defined
    上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。

    解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

    *解构赋值对提取 JSON 对象中的数据，尤其有用。*
    let jsonData = {
      id: 42,
      status: "OK",
      data: [867, 5309]
    };
    
    let { id, status, data: number } = jsonData;
    
    console.log(id, status, number);
    // 42, "OK", [867, 5309]
    
    String.fromCodePoint(大于0xFFFF的码点)方法 ---字符
    字符串实例.codePointAt()方法 ---码点

    字符串实例.includes()，返回布尔值，表示是否找到了参数字符串，支持第二个参数，表示开始搜索的位置

    字符串实例.repeat()，返回一个新字符串，表示将原字符串重复n次
    'x'.repeat(3) // "xxx"
    'hello'.repeat(2) // "hellohello"
    'na'.repeat(0) // ""

    ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
    // ES5的写法
    parseInt('12.34') // 12
    parseFloat('123.45#') // 123.45

    // ES6的写法
    Number.parseInt('12.34') // 12
    Number.parseFloat('123.45#') // 123.45
    这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

    Number.isInteger()用来判断一个数值是否为整数，但是如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。 

    ES6新增了一个指数运算符（**），这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。

    test
  </p>
</body>
</html>